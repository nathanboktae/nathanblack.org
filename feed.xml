<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://nathanblack.org</id>
    <title>Nathan Black&apos;s Blog</title>
    <updated>2017-01-30T00:00:00Z</updated>
    <link rel="alternate" href="http://nathanblack.org"/>
    <logo>http://nathanblack.org/favicon.png</logo>
    <generator>Feed for Node.js</generator>
    <entry>
        <title type="html"><![CDATA[Don't Mock Your Code - The Behavior is the Unit]]></title>
        <id>http://nathanblack.org/post/dont-mock-your-code-the-behavior-is-the-unit</id>
        <link href="http://nathanblack.org/post/dont-mock-your-code-the-behavior-is-the-unit">
        </link>
        <updated>2017-01-30T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>I first started really utilizing unit testing and test-driven development while on the <a href="http://web.archive.org/web/20120205035354/https://datamarket.azure.com/">DataMarket</a> team at Microsoft was slowing migrating an ASP.NET WebForms app to MVC. In a team that had no tests maintained by developers (<em>shudder</em> how did we develop software this long?) it was a big cultural change led by my great colleages <a href="https://github.com/jonsequitur">Jon Sequiera</a> and <a href="https://www.linkedin.com/in/dfrenkel">Dmitry Frenkel</a>, who I am very greatful to have the experience of working with.</p>
<p>At the time we&#39;d write tests for our controllers. We&#39;d mock out all the dependencies it would need in a test and provide them. We were also using the <a href="">repository pattern</a> and testing the controller we&#39;d mock that out. The repository pattern was really needed as we couldn&#39;t actually make a call to the database due to a lot of different reasons that basically stem from a monolithic ball of sphagetti code and abomination that was <a href="http://www.ben-morris.com/entity-framework-anti-patterns-how-not-to-use-an-orm-with-sql-server/">Entity Framework 1.0</a>.</p>
<p>That was nice to get developers used to writing tests for their code, but there was a lot of problems with that. Views were not tested at all, due to Razor being untestable at the time (some 32bit vs 64bit issue on the build server or something, see previous comment on monolithic ball of sphagetti). We had bugs in our view not being rendered. Razor was also very logic heavy, and a few abominations were created. Writing new tests required about 3x the mocking code than code that actually did the assertions. Model binding had no tests - you&#39;d know about it 3 days later (maybe) when a tester ran their test suite, or worse, your manager was trying something on the development environment. Forgot a dependency injection registration that you mocked out? App won&#39;t boot at all despite your tests passing. Moreover, when I want to refactor code to move more logic into the controller from the repository that had to much (that had no tests on it), I have to refactor a whole quite of tests. How can we rely on these tests when it still has these huge gaps and maintence problems?
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Migration to a static site: Experience with Metalsmith vs Gulp]]></title>
        <id>http://nathanblack.org/post/migration-to-static-site-via-gulp</id>
        <link href="http://nathanblack.org/post/migration-to-static-site-via-gulp">
        </link>
        <updated>2017-01-29T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>I <a href="/post/the-beginning">started this site</a> using <a href="http://jsantell.github.io/poet/">poet</a> on top of <a href="http://nodejs.org/">node.js</a> and <a href="http://expressjs.com/">express</a>, mainly wanting to expand my node skills and use my free Azure credits I got as a Microsoft employee. Azure Websites, the Heroku-like PaaS had just launched (now called <a href="https://azure.microsoft.com/en-us/services/app-service/">App Services</a>). It was a nice experience.</p>
<p>Later on while working at <a href="https://www.crunchbase.com/organization/appuri#/entity">Appuri</a>, we decided to move our public website off of Hubspot as it was a nightmare for our talented designer, <a href="https://www.linkedin.com/in/jeffreynoldz">Jeff Reynolds</a>, who knew HTML and CSS, to work in. It would need marketing functionality, but we took the approach that whatever we needed could be provided via a 3rd party JavaScript tag on the client. So we didn&#39;t need a server at all. We could simply serve it from an <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">S3 bucket</a> cheaply and it will always be up. <a href="https://circleci.com">Circle CI</a> would build the site and sync the bucket.</p>
<p>So how to build it? ]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Semantic Web Component Design: Radios, dropdowns, and tabs are the same thing]]></title>
        <id>http://nathanblack.org/post/semantic-web-component-design-dropdowns-tabs-radios-are-the-same-thing</id>
        <link href="http://nathanblack.org/post/semantic-web-component-design-dropdowns-tabs-radios-are-the-same-thing">
        </link>
        <updated>2016-12-10T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>Early on in the rewrite of <a href="https://www.appuri.com/">Appuri&#39;s</a> portal that we started on after having a designer and development team from the MVP, and in our transition from Angular to Knockout, I was looking around at different widget / web component libraries and what I could leverage that would fit the designer&#39;s use cases and style, as well as a clean design.</p>
<p>One thing that always drove me nuts about our previous UI was a mismash of different components doing the same thing. We had <a href="https://github.com/angular-ui/ui-select2">ui-select2</a>, <a href="http://angular-ui.github.io/ui-select/">ui-select</a> from the Angular UI team, <a href="https://github.com/isteven/angular-multi-select">angular-multi-select</a> for some multiselect cases, and a custom directive for radio-like toggle boxes.</p>
<p>Each control offered some little feature that another didn&#39;t (except <code>ui-select2</code> which was just in code we didn&#39;t get around to refactoring yet). Why is this? All of them are trying to do the same thing on a higher semantic level: The user needs to pick an one (or more) options from this fixed set of options. How that looks is a styling concern.
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[A fast and robust way to run Sauce Labs tests in Circle CI]]></title>
        <id>http://nathanblack.org/post/robustly-running-sauce-lab-test-in-circle-ci</id>
        <link href="http://nathanblack.org/post/robustly-running-sauce-lab-test-in-circle-ci">
        </link>
        <updated>2015-09-17T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>We&#39;ve been using <a href="https://circleci.com">Circle CI</a> at <a href="http://www.appuri.com">Appuri</a> for many months now and have been very happy with it. It&#39;s very simple and has a great breadth of features, namely the ability to SSH into a build to diagnose it when things get really tricky, as well as docker build services, slack integration, and lots of built-in services. After I hit a wall with <a href="http://phantomjs.org">PhantomJS</a>, and needing to run our tests on multiple browsers anyways, it was time to integrate <a href="">Sauce Labs</a> to do our browser testing, which I&#39;ve had great experience with on <a href="https://github.com/nathanboktae/cherrytree-for-knockout">many</a> <a href="https://github.com/nathanboktae/frypan-knockout-grid">open source</a> <a href="https://github.com/nathanboktae/knockout-choose">projects</a>. In those projects I used <a href="https://github.com/axemclion/grunt-saucelabs">grunt-saucelabs</a> as I am not a big fan of Karma as I like to control the HTML page the tests run on as well as the simplicity of <a href="https://github.com/nathanboktae/mocha-phantomjs">mocha-phantomjs</a> and just refreshing a flat file or using <a href="http://www.browsersync.io/">browser sync</a>.</p>
<p>However we&#39;re using <a href="http://gulpjs.com/">gulp</a> and I didn&#39;t want to pull in <a href="http://gruntjs.com/">grunt</a> and have two build systems. Unfortunately there&#39;s no <code>gulp-saucelabs</code>, which I contemplated doing (I may sometime), but I found I could simply use <a href="https://github.com/nathanboktae/mocha-cloud">mocha-cloud</a>. However, it didn&#39;t bring up the tunnel.</p>
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[jspm and systemjs: High friction package managment]]></title>
        <id>http://nathanblack.org/post/jspm-high-friction-package-management-avoid</id>
        <link href="http://nathanblack.org/post/jspm-high-friction-package-management-avoid">
        </link>
        <updated>2015-07-11T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>We have a decent-sized Angular codebase here at <a href="http://www.appuri.com/">Appuri</a> that I want to replace with real module system that will allow for a gradual move away from Angular. A friend recently pointed me to <a href="http://jspm.io/">jspm</a> and <a href="https://github.com/systemjs/systemjs">systemjs</a>. The goal and direction is sound - load any module format (AMD, CommonJS, Harmony/ES6) and be registry-agnostic (npm or GitHub is out of the box with registry plugins, namely for bower). Unlike bower, since the loader and the package manager work together, it maintains the mapping of modules that normally you do manually in <a href="http://requirejs.org/docs/api.html#config">the <code>map</code> and <code>paths</code> sections of your RequireJS main</a>. It also has a builder, so you can work in a mode that loads files individually, or bundle them up together for production, with source maps and minifcation. It also supports ES6 compiling to ES5 (or &quot;transpiling&quot; <a href="https://twitter.com/mraleph/status/471756991527124993">if you don&#39;t fully understand what compiling is</a>), so it is very future-standards focused. It&#39;s a superset of what I want from RequireJS, so I was excited and dove in.</p>
<p>Three days in, I&#39;m ready to throw in the towel as <a href="https://github.com/systemjs/builder/issues/223">I can&#39;t get SystemJS builder to work</a>. There are bigger issues too.</p>
<ol>
<li><h2 id="bower-should-be-a-first-class-registry">Bower should be a first class registry</h2>
<p>So jspm is registry agnostic, and it&#39;s registry providers built in are npm and GitHub. Why a GitHub provder instead of bower? It&#39;s so similar to bower, yet lacking too. They are both git based (well except these muts be in GitHub, damn your priviate or alternate git repo). It also ignores dependencies in the bower.json - which basically defeats the purpose of the package manager as you are now left to dealing with the dependecies yourself, manually editing your <code>config.js</code> - the thing that it&#39;s supposed to manage for you.</p>
<p>I started out simply using <code>jspm install angular</code>. Worked fine. Then trying to install angular plugins, they weren&#39;t in the registry. so I did them mangually via <code>jspm install github:somedude/angular-plugin</code>. However they would often just have a bower.json, so the dependency on angular wasn&#39;t declared. It was worse as I did <code>angular-chart</code>, which depends on <code>c3</code>, which then depends on <code>d3</code>.</p>
<p>Ugh. So I install <a href="https://www.npmjs.com/package/jspm-bower-endpoint">jspm-bower-endpoint</a> and run <code>jspm install bower:angular-chart</code>. cool.... wait, it depends on <code>bower:angular</code>, but I already have <code>github:angular</code> installed from the jspm registry... Ugh. <code>jspm uninstall</code> ALL the jspm packages and just use the bower registry, otherwise unless the jspm registry is 100% complete, you&#39;ll just have a mess to manually maintain. The same is true if you mixed and matched <code>npm</code> with <code>bower</code>, unless the dependencies didn&#39;t cross. BTW, you still need to have a <code>package.json</code> to get <code>jspm</code> down anyways.... so you have 2 package maangers. Actually, 2 package managers and a package manager registry wrapper.</p>
</li>
<li><h2 id="automatic-module-detection-really-does-not-work">Automatic module detection really does not work</h2>
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular's module system fails at tracking dependencies properly]]></title>
        <id>http://nathanblack.org/post/angular-module-system-fails-to-track-dependencies</id>
        <link href="http://nathanblack.org/post/angular-module-system-fails-to-track-dependencies">
        </link>
        <updated>2015-05-15T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://angularjs.org/">Angular</a>, being a framework with a lot of solutions to a problem, forces users to use modules - a very good thing. However, rather than letting users choose their module and package system (<a href="http://requirejs.org/">RequireJS</a> or <a href="http://browserify.org/">Browserify</a> or <a href="http://webpack.github.io/">Webpack</a> for loaders and AMD vs CommonJS vs Harmony for module formats), it brings in it&#39;s own module format, without a loader.</p>
<p>Defining a module looks like this</p>
<pre><code class="lang-javascript">var module = angular.module(&#39;fruit-stand&#39;, [&#39;raspberries&#39;, &#39;strawberries&#39;, &#39;apples&#39;])
// define what the module is or has by calling methods on it
</code></pre>
<p>it also includes a dependency injection component, because, uh, that&#39;s what they use in Java so JavaScript needs one too, because modules can&#39;t be scoped or replaced in a dynamic, interpretted language right? Nevermind. Well here&#39;s how it works:</p>
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Browserify string transforms: Use rfileify]]></title>
        <id>http://nathanblack.org/post/browserify-string-transforms-use-rfileify</id>
        <link href="http://nathanblack.org/post/browserify-string-transforms-use-rfileify">
        </link>
        <updated>2014-06-01T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>I started to use <a href="http://browserify.org/">browserify</a> for the first time day. It is quite slick - Just <code>npm install</code> something then <code>require</code> it up, with a lot less wiring up needed than using AMD. However adding a forced build step is not fun and I think would really be a killer on a big project.</p>
<p>So I began to look for a transform so I could include templates as I needed to bundle everything into one script. How hard can it be to basically do <code>&quot;module.exports = &quot; + JSON.stringify(fileContents)</code> ? Well after a couple hours of searching and trying 3 modules, the 4th one worked.</p>
<ul>
<li><a href="https://github.com/JohnPostlethwait/stringify">stringify</a> (no tests at all for this project)</li>
<li><a href="https://github.com/eugeneware/browserify-string">browserify-string</a> (tests but no CI)</li>
<li><a href="https://github.com/pluma/string-to-jsify">string-to-jsify</a> (test and CI but not for the console use case, the 95% one)</li>
<li><a href="https://github.com/ForbesLindesay/rfileify">rfileify</a> (tests, CI, and mentioned from <a href="https://github.com/benbria/browserify-transform-tools">browserify-transform-tools</a>)</li>
</ul>
<p>Rfileify does other transforms too, but just not the SEO rank, so hopefully I can help that.
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Why node.js is Awesome, Part 2: Package and Dependency Management]]></title>
        <id>http://nathanblack.org/post/why-nodejs-is-awesome-part2-package-and-dependency-management</id>
        <link href="http://nathanblack.org/post/why-nodejs-is-awesome-part2-package-and-dependency-management">
        </link>
        <updated>2014-05-28T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>At the core of node is npm, the node package manager (which apparently <a href="https://www.npmjs.org/doc/faq.html#If-npm-is-an-acronym-why-is-it-never-capitalized">npm doesn&#39;t stand for that</a>). Having dependencies managed by a package system is huge. In Java and .NET, package managers have been added after the fact, if they are used at all. Often people end up checking in binaries that then makes the repository huge with information not pertinent to your product, which also results in binary merge conflicts. How do those get organized? A legacy codebase I work on has them scattered throughout 3 different locations, not to mention naming styles.</p>
<p>Npm standardizes this by having all the dependencies in a folder named node_modules <a href="https://www.npmjs.org/doc/faq.html#node_modules-is-the-name-of-my-deity-s-arch-rival-and-a-Forbidden-Word-in-my-religion-Can-I-configure-npm-to-use-a-different-folder">which cannot be renamed</a> and a package.json that must be comformant too, which then node understands when you <code>require</code> something. No need to set classpaths or hint paths correctly. </p>
<p>This also heavily pushes people to have all their dependies locally. Its still possible to have a global module installed and require it without declaring it in your package.json (Maybe there is a way to prevent this via static analysis?) You can end up pulling assemblies from the GAC in .NET too, but still so many packages aren&#39;t installable via NuGet (I&#39;m looking at you Azure SDK, which of course the Azure SDK for Node.js installs via npm) which means every developer and the build server(s) better have the same versions installed or someone will be wasting time getting stuff to build.</p>
<p>Dependencies are also a tree structure, not a graph. If two modules depend on the same module, they each get their own copy, so they can have their own versions. This is great given <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">prototypical inheritance</a>. If you want to be strict about the type of object you are working with, <code>instanceof</code> will only be true if your version of the module created the object, not another version , due to the constructor functions not being a reference to the same object. If you want to be lenient, you can always duck type it.</p>
<p>Statically typed languages have a graph of dependencies, and if A and B depend on different versions of C, pain will ensue. I gave seen .NET developers waste hours tracking down mismatching versions of dependencies, even with the help of assembly binding redirects. I don&#39;t think Java has any answer for this.
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The 4th aspect in JavaScript MVC frameworks]]></title>
        <id>http://nathanblack.org/post/the-4th-aspect-in-javascript-mvc-frameworks</id>
        <link href="http://nathanblack.org/post/the-4th-aspect-in-javascript-mvc-frameworks">
        </link>
        <updated>2014-04-27T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>Of the many JavaScript frameworks out there, they all have one core priciple - to structure your code in a <a href="http://blog.stevensanderson.com/2012/08/01/rich-javascript-applications-the-seven-frameworks-throne-of-js-2012/">Model-View-Whatever</a> style:</p>
<ul>
<li>Model: Your data as an object</li>
<li>Controller/ViewModel/Presenter/Whatever: the business logic of your app</li>
<li><p>View: The HTML templates for your app</p>
<p>But after using a few (Knockout, Angular, Ember, and Backbone) I&#39;ve noticed there&#39;s a forth component. It&#39;s the widgety type of logic - logic that isn&#39;t about your business, but extents the browser functionality - that cool datepicker, color picker, an awesome visualization with D3, maybe a 3D flip switch intstead of a checkbox. That stuff that is a DMZ to the DOM - Knockout&#39;s <code>bindingHandler</code>s, Angular&#39;s directives, and Handlebar helpers. They aren&#39;t about how you map your view model / controller to the DOM, but about extending the functionality of the DOM.</p>
<p>Why call this out? Well frameworks don&#39;t exactly agree on this terminology. With Knockout and Angular, the view is HTML, as they use DOM-based templating. In Ember, Backbone, and other string-based templating languages, they often refer to the view as a piece of JavaScript, and templating is separate. Really the template should be called the view in their world, and the view is this 4th aspect, the widget aspect. Knockout and Angular have their bindingHandlers / directives that extend their templating functionality, which are much more analogous to Ember/Backbone/Batman/etc views.</p>
<p>Why is this important? Keeping selector strings out of your controllers and view models is vital for the separation of concerns and tesability. Keeping this 4th aspect as the DMZ to the DOM helps to separate these concerns. Say you do have a complicated problem to solve in your app, and you come up with a cool way to visuallize it. You could put it all in one module... but now what happens when you release it and users don&#39;t like that widget and they want something more traditional? It will be harder to pull it out. Or the opposite where that widget is really awesome and you want to use it elsewhere... now lots of work to pull the business logic out. Let those two evolve independently and they grow and improve much more rapidly.</p>
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Why node.js is Awesome, Part 1: The Single Responsibility Principle]]></title>
        <id>http://nathanblack.org/post/why-nodejs-is-awesome-part1-single-responsiblity-principle</id>
        <link href="http://nathanblack.org/post/why-nodejs-is-awesome-part1-single-responsiblity-principle">
        </link>
        <updated>2014-04-04T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>My favorite thing about node.js and the npm community is something that can&#39;t easily be put on a spec sheet. It&#39;s adherance to the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single responsiblity principle</a>.</p>
<p>Take a look at some of the <a href="https://www.npmjs.org/">most depnended on npm modules</a> - they&#39;re often very small, like <a href="https://www.npmjs.org/package/mkdirp">mkdirp</a>, which is simply <code>mkdir -p</code> in node. <a href="https://www.npmjs.org/package/glob">glob</a> matches files like a shell does. <a href="https://www.npmjs.org/package/node-uuid">node-uuid</a> just generates UUIDs.</p>
<p>Is there a bug in the module? The module is small enough and tested well that you can dive in and help out, and send the bug fix as a pull request on GitHub. Don&#39;t like the design of the module your using, or development died out? Swap it out with a different module, and wire it up to your <a href="http://en.wikipedia.org/wiki/Loose_coupling">loosely coupled</a> system.</p>
<p>This is definately a change in culture, as though I didn&#39;t use Rails much, but that community likes it&#39;s big frameworks that do a lot of magic. Which is nice until you disagree with an aspect of that magic, or need to tweak it or swap it out with something else for this one scenario.</p>
<p>A great <a href="https://twitter.com/jonsequitur">coworker</a> of mine once told me &quot;The key to complexity is composition&quot;, which I have experienced to be true.
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Beginning]]></title>
        <id>http://nathanblack.org/post/the-beginning</id>
        <link href="http://nathanblack.org/post/the-beginning">
        </link>
        <updated>2014-03-30T00:00:00Z</updated>
        <summary type="html"><![CDATA[<p>After owning nathanblack.org for several years and doing web development, it&#39;s long overdue I have a blog with a few thoughts to share about web development.</p>
<p>This blog is powered by <a href="http://jsantell.github.io/poet/">poet</a> on top of <a href="http://nodejs.org/">node.js</a> and <a href="http://expressjs.com/">express.js</a>, with <a href="http://learnboost.github.io/stylus/">stylus</a> for the CSS preprocessor, but most importantly no jQuery and no bootstrap.</p>
<p><em>Update</em>: See the entry about <a href="/post/migration-to-static-site-via-gulp">the current setup</a>
]]></summary>
        <author>
            <name>Nathan Black</name>
            <uri>http://nathanblack.org/</uri>
        </author>
    </entry>
</feed>