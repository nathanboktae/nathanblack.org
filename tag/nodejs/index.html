<!DOCTYPE html><html><head><title>#nodejs - Nathan Black</title><meta charset="utf-8"><meta name="description" content="A blog about modern web development, from front end to Node.js, JavaScript, styling, testing, and software development practices"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/site.021b7ad.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400|Raleway|Nobile:400,700"></head><body><header><aside><a href="https://github.com/nathanboktae" class="github"></a><a href="https://plus.google.com/+NathanBlackJ" class="gplus"></a><a href="mailto:nathan@nathanblack.org" class="email"></a></aside><div class="logo"><img src="//gravatar.com/avatar/f78c2c988486648311bcf116070e2487.jpg?s=110"></div><h2><a href="/"><span class="name">nathanblack</span><span>.org</span></a></h2><h4>Refining Modern Web Development</h4></header><aside class="github"><h2><a href="https://github.com/nathanboktae"><b>@</b>nathanboktae</a></h2><ul data-bind="foreach: events" class="events"><li data-bind="attr: { class: type }"><span data-bind="text: when" class="date"></span><h3 data-bind="html: summary"></h3><p data-bind="text: $data.details"></p></li></ul></aside><article><h2 class="tag">nodejs</h2><section class="post-summary"><span class="date">Last Sunday at 12:00 AM</span><h1><a href="/post/migration-to-static-site-via-gulp">Migration to a static site: Experience with Metalsmith vs Gulp</a></h1><article></article><ul class="tags"><li><a href="/tag/nodejs">nodejs</a></li><li><a href="/tag/circle-ci">circle-ci</a></li><li><a href="/tag/gulp">gulp</a></li></ul></section><section class="post-summary"><span class="date">05/28/2014</span><h1><a href="/post/why-nodejs-is-awesome-part2-package-and-dependency-management">Why node.js is Awesome, Part 2: Package and Dependency Management</a></h1><article><p>At the core of node is npm, the node package manager (which apparently <a href="https://www.npmjs.org/doc/faq.html#If-npm-is-an-acronym-why-is-it-never-capitalized">npm doesn&#39;t stand for that</a>). Having dependencies managed by a package system is huge. In Java and .NET, package managers have been added after the fact, if they are used at all. Often people end up checking in binaries that then makes the repository huge with information not pertinent to your product, which also results in binary merge conflicts. How do those get organized? A legacy codebase I work on has them scattered throughout 3 different locations, not to mention naming styles.</p>
<p>Npm standardizes this by having all the dependencies in a folder named node_modules <a href="https://www.npmjs.org/doc/faq.html#node_modules-is-the-name-of-my-deity-s-arch-rival-and-a-Forbidden-Word-in-my-religion-Can-I-configure-npm-to-use-a-different-folder">which cannot be renamed</a> and a package.json that must be comformant too, which then node understands when you <code>require</code> something. No need to set classpaths or hint paths correctly. </p>
<p>This also heavily pushes people to have all their dependies locally. Its still possible to have a global module installed and require it without declaring it in your package.json (Maybe there is a way to prevent this via static analysis?) You can end up pulling assemblies from the GAC in .NET too, but still so many packages aren&#39;t installable via NuGet (I&#39;m looking at you Azure SDK, which of course the Azure SDK for Node.js installs via npm) which means every developer and the build server(s) better have the same versions installed or someone will be wasting time getting stuff to build.</p>
<p>Dependencies are also a tree structure, not a graph. If two modules depend on the same module, they each get their own copy, so they can have their own versions. This is great given <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">prototypical inheritance</a>. If you want to be strict about the type of object you are working with, <code>instanceof</code> will only be true if your version of the module created the object, not another version , due to the constructor functions not being a reference to the same object. If you want to be lenient, you can always duck type it.</p>
<p>Statically typed languages have a graph of dependencies, and if A and B depend on different versions of C, pain will ensue. I gave seen .NET developers waste hours tracking down mismatching versions of dependencies, even with the help of assembly binding redirects. I don&#39;t think Java has any answer for this.
</article><ul class="tags"><li><a href="/tag/nodejs">nodejs</a></li><li><a href="/tag/npm">npm</a></li><li><a href="/tag/dependencies">dependencies</a></li></ul></section><section class="post-summary"><span class="date">04/04/2014</span><h1><a href="/post/why-nodejs-is-awesome-part1-single-responsiblity-principle">Why node.js is Awesome, Part 1: The Single Responsibility Principle</a></h1><article><p>My favorite thing about node.js and the npm community is something that can&#39;t easily be put on a spec sheet. It&#39;s adherance to the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single responsiblity principle</a>.</p>
<p>Take a look at some of the <a href="https://www.npmjs.org/">most depnended on npm modules</a> - they&#39;re often very small, like <a href="https://www.npmjs.org/package/mkdirp">mkdirp</a>, which is simply <code>mkdir -p</code> in node. <a href="https://www.npmjs.org/package/glob">glob</a> matches files like a shell does. <a href="https://www.npmjs.org/package/node-uuid">node-uuid</a> just generates UUIDs.</p>
<p>Is there a bug in the module? The module is small enough and tested well that you can dive in and help out, and send the bug fix as a pull request on GitHub. Don&#39;t like the design of the module your using, or development died out? Swap it out with a different module, and wire it up to your <a href="http://en.wikipedia.org/wiki/Loose_coupling">loosely coupled</a> system.</p>
<p>This is definately a change in culture, as though I didn&#39;t use Rails much, but that community likes it&#39;s big frameworks that do a lot of magic. Which is nice until you disagree with an aspect of that magic, or need to tweak it or swap it out with something else for this one scenario.</p>
<p>A great <a href="https://twitter.com/jonsequitur">coworker</a> of mine once told me &quot;The key to complexity is composition&quot;, which I have experienced to be true.
</article><ul class="tags"><li><a href="/tag/nodejs">nodejs</a></li><li><a href="/tag/single-responsiblity">single-responsiblity</a></li><li><a href="/tag/"></a></li></ul></section><section class="post-summary"><span class="date">03/30/2014</span><h1><a href="/post/the-beginning">The Beginning</a></h1><article></article><ul class="tags"><li><a href="/tag/nodejs">nodejs</a></li></ul></section></article><script src="/site.021b7ad.js"></script></body></html>