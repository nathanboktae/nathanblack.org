<!DOCTYPE html><html><head><title>#angular - Nathan Black</title><meta charset="utf-8"><meta name="description" content="A blog about modern web development, from front end to Node.js, JavaScript, styling, testing, and software development practices"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/site.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400|Raleway|Nobile:400,700"></head><body><header><aside><a href="https://github.com/nathanboktae" class="github"></a><a href="https://plus.google.com/+NathanBlackJ" class="gplus"></a><a href="mailto:nathan@nathanblack.org" class="email"></a></aside><div class="logo"><img src="//gravatar.com/avatar/f78c2c988486648311bcf116070e2487.jpg?s=110"></div><h2><a href="/"><span class="name">nathanblack</span><span>.org</span></a></h2><h4>Refining Modern Web Development</h4></header><aside class="github"><h2><a href="https://github.com/nathanboktae"><b>@</b>nathanboktae</a></h2><ul data-bind="foreach: events" class="events"><li data-bind="attr: { class: type }"><span data-bind="text: when" class="date"></span><h3 data-bind="html: summary"></h3><p data-bind="text: $data.details"></p></li></ul></aside><article><h2 class="tag">angular</h2><section class="post-summary"><span class="date">12/10/2016</span><h1><a href="/post/semantic-web-component-design-dropdowns-tabs-radios-are-the-same-thing">Semantic Web Component Design: Radios, dropdowns, and tabs are the same thing</a></h1><article><p>Early on in the rewrite of <a href="https://www.appuri.com/">Appuri&#39;s</a> portal that we started on after having a designer and development team from the MVP, and in our transition from Angular to Knockout, I was looking around at different widget / web component libraries and what I could leverage that would fit the designer&#39;s use cases and style, as well as a clean design.</p>
<p>One thing that always drove me nuts about our previous UI was a mismash of different components doing the same thing. We had <a href="https://github.com/angular-ui/ui-select2">ui-select2</a>, <a href="http://angular-ui.github.io/ui-select/">ui-select</a> from the Angular UI team, <a href="https://github.com/isteven/angular-multi-select">angular-multi-select</a> for some multiselect cases, and a custom directive for radio-like toggle boxes.</p>
<p>Each control offered some little feature that another didn&#39;t (except <code>ui-select2</code> which was just in code we didn&#39;t get around to refactoring yet). Why is this? All of them are trying to do the same thing on a higher semantic level: The user needs to pick an one (or more) options from this fixed set of options. How that looks is a styling concern.
</article><ul class="tags"><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/semantic-html">semantic-html</a></li><li><a href="/tag/web-components">web-components</a></li><li><a href="/tag/angular">angular</a></li><li><a href="/tag/knockout">knockout</a></li></ul></section><section class="post-summary"><span class="date">05/15/2015</span><h1><a href="/post/angular-module-system-fails-to-track-dependencies">Angular's module system fails at tracking dependencies properly</a></h1><article><p><a href="https://angularjs.org/">Angular</a>, being a framework with a lot of solutions to a problem, forces users to use modules - a very good thing. However, rather than letting users choose their module and package system (<a href="http://requirejs.org/">RequireJS</a> or <a href="http://browserify.org/">Browserify</a> or <a href="http://webpack.github.io/">Webpack</a> for loaders and AMD vs CommonJS vs Harmony for module formats), it brings in it&#39;s own module format, without a loader.</p>
<p>Defining a module looks like this</p>
<pre><code class="lang-javascript">var module = angular.module(&#39;fruit-stand&#39;, [&#39;raspberries&#39;, &#39;strawberries&#39;, &#39;apples&#39;])
// define what the module is or has by calling methods on it
</code></pre>
<p>it also includes a dependency injection component, because, uh, that&#39;s what they use in Java so JavaScript needs one too, because modules can&#39;t be scoped or replaced in a dynamic, interpretted language right? Nevermind. Well here&#39;s how it works:</p>
</article><ul class="tags"><li><a href="/tag/angular">angular</a></li><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/modules">modules</a></li></ul></section><section class="post-summary"><span class="date">04/27/2014</span><h1><a href="/post/the-4th-aspect-in-javascript-mvc-frameworks">The 4th aspect in JavaScript MVC frameworks</a></h1><article><p>Of the many JavaScript frameworks out there, they all have one core priciple - to structure your code in a <a href="http://blog.stevensanderson.com/2012/08/01/rich-javascript-applications-the-seven-frameworks-throne-of-js-2012/">Model-View-Whatever</a> style:</p>
<ul>
<li>Model: Your data as an object</li>
<li>Controller/ViewModel/Presenter/Whatever: the business logic of your app</li>
<li><p>View: The HTML templates for your app</p>
<p>But after using a few (Knockout, Angular, Ember, and Backbone) I&#39;ve noticed there&#39;s a forth component. It&#39;s the widgety type of logic - logic that isn&#39;t about your business, but extents the browser functionality - that cool datepicker, color picker, an awesome visualization with D3, maybe a 3D flip switch intstead of a checkbox. That stuff that is a DMZ to the DOM - Knockout&#39;s <code>bindingHandler</code>s, Angular&#39;s directives, and Handlebar helpers. They aren&#39;t about how you map your view model / controller to the DOM, but about extending the functionality of the DOM.</p>
<p>Why call this out? Well frameworks don&#39;t exactly agree on this terminology. With Knockout and Angular, the view is HTML, as they use DOM-based templating. In Ember, Backbone, and other string-based templating languages, they often refer to the view as a piece of JavaScript, and templating is separate. Really the template should be called the view in their world, and the view is this 4th aspect, the widget aspect. Knockout and Angular have their bindingHandlers / directives that extend their templating functionality, which are much more analogous to Ember/Backbone/Batman/etc views.</p>
<p>Why is this important? Keeping selector strings out of your controllers and view models is vital for the separation of concerns and tesability. Keeping this 4th aspect as the DMZ to the DOM helps to separate these concerns. Say you do have a complicated problem to solve in your app, and you come up with a cool way to visuallize it. You could put it all in one module... but now what happens when you release it and users don&#39;t like that widget and they want something more traditional? It will be harder to pull it out. Or the opposite where that widget is really awesome and you want to use it elsewhere... now lots of work to pull the business logic out. Let those two evolve independently and they grow and improve much more rapidly.</p>
</article><ul class="tags"><li><a href="/tag/mvc">mvc</a></li><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/knockout">knockout</a></li><li><a href="/tag/angular">angular</a></li><li><a href="/tag/ember">ember</a></li><li><a href="/tag/"></a></li></ul></section></article><script src="/site.js"></script></body></html>