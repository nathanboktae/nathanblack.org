<!DOCTYPE html><html><head><title>#front-end - Nathan Black</title><meta charset="utf-8"><meta name="description" content="A blog about modern web development, from front end to Node.js, JavaScript, styling, testing, and software development practices"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/site.b7837c4.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400|Raleway|Nobile:400,700"></head><body><header><aside><a href="https://github.com/nathanboktae" class="github"></a><a href="https://linkedin.com/in/nathanjblack" class="linkedin"></a><a href="mailto:nathan@nathanblack.org" class="email"></a></aside><div class="logo"><img src="//gravatar.com/avatar/f78c2c988486648311bcf116070e2487.jpg?s=110"></div><h2><a href="/"><span class="name">nathanblack</span><span>.org</span></a></h2><h4>Refining Modern Web Development</h4></header><aside class="github"><h2><a href="https://github.com/nathanboktae"><b>@</b>nathanboktae</a></h2><ul data-bind="foreach: events" class="events"><li data-bind="attr: { class: type }"><span data-bind="text: when" class="date"></span><h3 data-bind="html: summary"></h3><p data-bind="text: $data.details"></p></li></ul></aside><article><h2 class="tag">front-end</h2><section class="post-summary truncated"><span class="date">Monday, January 30th 2017</span><h1><a href="/post/dont-mock-your-code-the-behavior-is-the-unit">Don't Mock Your Code - The Behavior is the Unit</a></h1><article><p>I first started really utilizing unit testing and test-driven development while on the <a href="http://web.archive.org/web/20120205035354/https://datamarket.azure.com/">DataMarket</a> team at Microsoft was slowing migrating an ASP.NET WebForms app to MVC. In a team that had no tests maintained by developers (<em>shudder</em> how did we develop software this long?) it was a big cultural change led by my great colleages <a href="https://github.com/jonsequitur">Jon Sequiera</a> and <a href="https://www.linkedin.com/in/dfrenkel">Dmitry Frenkel</a>, who I am very greatful to have the experience of working with.</p>
<p>At the time we&#39;d write tests for our controllers. We&#39;d mock out all the dependencies it would need in a test and provide them. We were also using the <a href="">repository pattern</a> and testing the controller we&#39;d mock that out. The repository pattern was really needed as we couldn&#39;t actually make a call to the database due to a lot of different reasons that basically stem from a monolithic ball of sphagetti code and abomination that was <a href="http://www.ben-morris.com/entity-framework-anti-patterns-how-not-to-use-an-orm-with-sql-server/">Entity Framework 1.0</a>.</p>
<p>That was nice to get developers used to writing tests for their code, but there was a lot of problems with that. Views were not tested at all, due to Razor being untestable at the time (some 32bit vs 64bit issue on the build server or something, see previous comment on monolithic ball of sphagetti). We had bugs in our view not being rendered. Razor was also very logic heavy, and a few abominations were created. Writing new tests required about 3x the mocking code than code that actually did the assertions. Model binding had no tests - you&#39;d know about it 3 days later (maybe) when a tester ran their test suite, or worse, your manager was trying something on the development environment. Forgot a dependency injection registration that you mocked out? App won&#39;t boot at all despite your tests passing. Moreover, when I want to refactor code to move more logic into the controller from the repository that had to much (that had no tests on it), I have to refactor a whole quite of tests. How can we rely on these tests when it still has these huge gaps and maintence problems?
</article><ul class="tags"><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/testing">testing</a></li><li><a href="/tag/bdd">bdd</a></li></ul></section><section class="post-summary truncated"><span class="date">Saturday, December 10th 2016</span><h1><a href="/post/semantic-web-component-design-dropdowns-tabs-radios-are-the-same-thing">Semantic Web Component Design: Radios, dropdowns, and tabs are the same thing</a></h1><article><p>Early on in the rewrite of <a href="https://www.appuri.com/">Appuri&#39;s</a> portal that we started on after having a designer and development team from the MVP, and in our transition from Angular to Knockout, I was looking around at different widget / web component libraries and what I could leverage that would fit the designer&#39;s use cases and style, as well as a clean design.</p>
<p>One thing that always drove me nuts about our previous UI was a mismash of different components doing the same thing. We had <a href="https://github.com/angular-ui/ui-select2">ui-select2</a>, <a href="http://angular-ui.github.io/ui-select/">ui-select</a> from the Angular UI team, <a href="https://github.com/isteven/angular-multi-select">angular-multi-select</a> for some multiselect cases, and a custom directive for radio-like toggle boxes.</p>
<p>Each control offered some little feature that another didn&#39;t (except <code>ui-select2</code> which was just in code we didn&#39;t get around to refactoring yet). Why is this? All of them are trying to do the same thing on a higher semantic level: The user needs to pick an one (or more) options from this fixed set of options. How that looks is a styling concern.
</article><ul class="tags"><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/semantic-html">semantic-html</a></li><li><a href="/tag/web-components">web-components</a></li><li><a href="/tag/angular">angular</a></li><li><a href="/tag/knockout">knockout</a></li></ul></section><section class="post-summary truncated"><span class="date">Thursday, September 17th 2015</span><h1><a href="/post/robustly-running-sauce-lab-test-in-circle-ci">A fast and robust way to run Sauce Labs tests in Circle CI</a></h1><article><p>We&#39;ve been using <a href="https://circleci.com">Circle CI</a> at <a href="http://www.appuri.com">Appuri</a> for many months now and have been very happy with it. It&#39;s very simple and has a great breadth of features, namely the ability to SSH into a build to diagnose it when things get really tricky, as well as docker build services, slack integration, and lots of built-in services. After I hit a wall with <a href="http://phantomjs.org">PhantomJS</a>, and needing to run our tests on multiple browsers anyways, it was time to integrate <a href="">Sauce Labs</a> to do our browser testing, which I&#39;ve had great experience with on <a href="https://github.com/nathanboktae/cherrytree-for-knockout">many</a> <a href="https://github.com/nathanboktae/frypan-knockout-grid">open source</a> <a href="https://github.com/nathanboktae/knockout-choose">projects</a>. In those projects I used <a href="https://github.com/axemclion/grunt-saucelabs">grunt-saucelabs</a> as I am not a big fan of Karma as I like to control the HTML page the tests run on as well as the simplicity of <a href="https://github.com/nathanboktae/mocha-phantomjs">mocha-phantomjs</a> and just refreshing a flat file or using <a href="http://www.browsersync.io/">browser sync</a>.</p>
<p>However we&#39;re using <a href="http://gulpjs.com/">gulp</a> and I didn&#39;t want to pull in <a href="http://gruntjs.com/">grunt</a> and have two build systems. Unfortunately there&#39;s no <code>gulp-saucelabs</code>, which I contemplated doing (I may sometime), but I found I could simply use <a href="https://github.com/nathanboktae/mocha-cloud">mocha-cloud</a>. However, it didn&#39;t bring up the tunnel.</p>
</article><ul class="tags"><li><a href="/tag/continuous-integration">continuous-integration</a></li><li><a href="/tag/testing">testing</a></li><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/sauce-labs">sauce-labs</a></li><li><a href="/tag/circle-ci">circle-ci</a></li></ul></section><section class="post-summary truncated"><span class="date">Saturday, July 11th 2015</span><h1><a href="/post/jspm-high-friction-package-management-avoid">jspm and systemjs: High friction package managment</a></h1><article><p>We have a decent-sized Angular codebase here at <a href="http://www.appuri.com/">Appuri</a> that I want to replace with real module system that will allow for a gradual move away from Angular. A friend recently pointed me to <a href="http://jspm.io/">jspm</a> and <a href="https://github.com/systemjs/systemjs">systemjs</a>. The goal and direction is sound - load any module format (AMD, CommonJS, Harmony/ES6) and be registry-agnostic (npm or GitHub is out of the box with registry plugins, namely for bower). Unlike bower, since the loader and the package manager work together, it maintains the mapping of modules that normally you do manually in <a href="http://requirejs.org/docs/api.html#config">the <code>map</code> and <code>paths</code> sections of your RequireJS main</a>. It also has a builder, so you can work in a mode that loads files individually, or bundle them up together for production, with source maps and minifcation. It also supports ES6 compiling to ES5 (or &quot;transpiling&quot; <a href="https://twitter.com/mraleph/status/471756991527124993">if you don&#39;t fully understand what compiling is</a>), so it is very future-standards focused. It&#39;s a superset of what I want from RequireJS, so I was excited and dove in.</p>
<p>Three days in, I&#39;m ready to throw in the towel as <a href="https://github.com/systemjs/builder/issues/223">I can&#39;t get SystemJS builder to work</a>. There are bigger issues too.</p>
<ol>
<li><h2 id="bower-should-be-a-first-class-registry">Bower should be a first class registry</h2>
<p>So jspm is registry agnostic, and it&#39;s registry providers built in are npm and GitHub. Why a GitHub provder instead of bower? It&#39;s so similar to bower, yet lacking too. They are both git based (well except these muts be in GitHub, damn your priviate or alternate git repo). It also ignores dependencies in the bower.json - which basically defeats the purpose of the package manager as you are now left to dealing with the dependecies yourself, manually editing your <code>config.js</code> - the thing that it&#39;s supposed to manage for you.</p>
<p>I started out simply using <code>jspm install angular</code>. Worked fine. Then trying to install angular plugins, they weren&#39;t in the registry. so I did them mangually via <code>jspm install github:somedude/angular-plugin</code>. However they would often just have a bower.json, so the dependency on angular wasn&#39;t declared. It was worse as I did <code>angular-chart</code>, which depends on <code>c3</code>, which then depends on <code>d3</code>.</p>
<p>Ugh. So I install <a href="https://www.npmjs.com/package/jspm-bower-endpoint">jspm-bower-endpoint</a> and run <code>jspm install bower:angular-chart</code>. cool.... wait, it depends on <code>bower:angular</code>, but I already have <code>github:angular</code> installed from the jspm registry... Ugh. <code>jspm uninstall</code> ALL the jspm packages and just use the bower registry, otherwise unless the jspm registry is 100% complete, you&#39;ll just have a mess to manually maintain. The same is true if you mixed and matched <code>npm</code> with <code>bower</code>, unless the dependencies didn&#39;t cross. BTW, you still need to have a <code>package.json</code> to get <code>jspm</code> down anyways.... so you have 2 package maangers. Actually, 2 package managers and a package manager registry wrapper.</p>
</li>
<li><h2 id="automatic-module-detection-really-does-not-work">Automatic module detection really does not work</h2>
</article><ul class="tags"><li><a href="/tag/jspm">jspm</a></li><li><a href="/tag/systemjs">systemjs</a></li><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/package managers">package managers</a></li><li><a href="/tag/modules">modules</a></li></ul></section><section class="post-summary truncated"><span class="date">Friday, May 15th 2015</span><h1><a href="/post/angular-module-system-fails-to-track-dependencies">Angular's module system fails at tracking dependencies properly</a></h1><article><p><a href="https://angularjs.org/">Angular</a>, being a framework with a lot of solutions to a problem, forces users to use modules - a very good thing. However, rather than letting users choose their module and package system (<a href="http://requirejs.org/">RequireJS</a> or <a href="http://browserify.org/">Browserify</a> or <a href="http://webpack.github.io/">Webpack</a> for loaders and AMD vs CommonJS vs Harmony for module formats), it brings in it&#39;s own module format, without a loader.</p>
<p>Defining a module looks like this</p>
<pre><code class="lang-javascript">var module = angular.module(&#39;fruit-stand&#39;, [&#39;raspberries&#39;, &#39;strawberries&#39;, &#39;apples&#39;])
// define what the module is or has by calling methods on it
</code></pre>
<p>it also includes a dependency injection component, because, uh, that&#39;s what they use in Java so JavaScript needs one too, because modules can&#39;t be scoped or replaced in a dynamic, interpretted language right? Nevermind. Well here&#39;s how it works:</p>
</article><ul class="tags"><li><a href="/tag/angular">angular</a></li><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/modules">modules</a></li></ul></section><section class="post-summary"><span class="date">Sunday, June 1st 2014</span><h1><a href="/post/browserify-string-transforms-use-rfileify">Browserify string transforms: Use rfileify</a></h1><article><p>I started to use <a href="http://browserify.org/">browserify</a> for the first time day. It is quite slick - Just <code>npm install</code> something then <code>require</code> it up, with a lot less wiring up needed than using AMD. However adding a forced build step is not fun and I think would really be a killer on a big project.</p>
<p>So I began to look for a transform so I could include templates as I needed to bundle everything into one script. How hard can it be to basically do <code>&quot;module.exports = &quot; + JSON.stringify(fileContents)</code> ? Well after a couple hours of searching and trying 3 modules, the 4th one worked.</p>
<ul>
<li><a href="https://github.com/JohnPostlethwait/stringify">stringify</a> (no tests at all for this project)</li>
<li><a href="https://github.com/eugeneware/browserify-string">browserify-string</a> (tests but no CI)</li>
<li><a href="https://github.com/pluma/string-to-jsify">string-to-jsify</a> (test and CI but not for the console use case, the 95% one)</li>
<li><a href="https://github.com/ForbesLindesay/rfileify">rfileify</a> (tests, CI, and mentioned from <a href="https://github.com/benbria/browserify-transform-tools">browserify-transform-tools</a>)</li>
</ul>
<p>Rfileify does other transforms too, but just not the SEO rank, so hopefully I can help that.
</article><ul class="tags"><li><a href="/tag/browserify">browserify</a></li><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/npm">npm</a></li><li><a href="/tag/dependencies">dependencies</a></li></ul></section><section class="post-summary"><span class="date">Sunday, April 27th 2014</span><h1><a href="/post/the-4th-aspect-in-javascript-mvc-frameworks">The 4th aspect in JavaScript MVC frameworks</a></h1><article><p>Of the many JavaScript frameworks out there, they all have one core priciple - to structure your code in a <a href="http://blog.stevensanderson.com/2012/08/01/rich-javascript-applications-the-seven-frameworks-throne-of-js-2012/">Model-View-Whatever</a> style:</p>
<ul>
<li>Model: Your data as an object</li>
<li>Controller/ViewModel/Presenter/Whatever: the business logic of your app</li>
<li><p>View: The HTML templates for your app</p>
<p>But after using a few (Knockout, Angular, Ember, and Backbone) I&#39;ve noticed there&#39;s a forth component. It&#39;s the widgety type of logic - logic that isn&#39;t about your business, but extents the browser functionality - that cool datepicker, color picker, an awesome visualization with D3, maybe a 3D flip switch intstead of a checkbox. That stuff that is a DMZ to the DOM - Knockout&#39;s <code>bindingHandler</code>s, Angular&#39;s directives, and Handlebar helpers. They aren&#39;t about how you map your view model / controller to the DOM, but about extending the functionality of the DOM.</p>
<p>Why call this out? Well frameworks don&#39;t exactly agree on this terminology. With Knockout and Angular, the view is HTML, as they use DOM-based templating. In Ember, Backbone, and other string-based templating languages, they often refer to the view as a piece of JavaScript, and templating is separate. Really the template should be called the view in their world, and the view is this 4th aspect, the widget aspect. Knockout and Angular have their bindingHandlers / directives that extend their templating functionality, which are much more analogous to Ember/Backbone/Batman/etc views.</p>
<p>Why is this important? Keeping selector strings out of your controllers and view models is vital for the separation of concerns and tesability. Keeping this 4th aspect as the DMZ to the DOM helps to separate these concerns. Say you do have a complicated problem to solve in your app, and you come up with a cool way to visuallize it. You could put it all in one module... but now what happens when you release it and users don&#39;t like that widget and they want something more traditional? It will be harder to pull it out. Or the opposite where that widget is really awesome and you want to use it elsewhere... now lots of work to pull the business logic out. Let those two evolve independently and they grow and improve much more rapidly.</p>
</article><ul class="tags"><li><a href="/tag/mvc">mvc</a></li><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/knockout">knockout</a></li><li><a href="/tag/angular">angular</a></li><li><a href="/tag/ember">ember</a></li><li><a href="/tag/"></a></li></ul></section></article><script src="/site.b7837c4.js"></script></body></html>