<!DOCTYPE html><html><head><title>Don't Mock Your Code - The Behavior is the Unit - Nathan Black</title><meta charset="utf-8"><meta name="description" content="A blog about modern web development, from front end to Node.js, JavaScript, styling, testing, and software development practices"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/site.021b7ad.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400|Raleway|Nobile:400,700"></head><body><header><aside><a href="https://github.com/nathanboktae" class="github"></a><a href="https://plus.google.com/+NathanBlackJ" class="gplus"></a><a href="mailto:nathan@nathanblack.org" class="email"></a></aside><div class="logo"><img src="//gravatar.com/avatar/f78c2c988486648311bcf116070e2487.jpg?s=110"></div><h2><a href="/"><span class="name">nathanblack</span><span>.org</span></a></h2><h4>Refining Modern Web Development</h4></header><aside class="github"><h2><a href="https://github.com/nathanboktae"><b>@</b>nathanboktae</a></h2><ul data-bind="foreach: events" class="events"><li data-bind="attr: { class: type }"><span data-bind="text: when" class="date"></span><h3 data-bind="html: summary"></h3><p data-bind="text: $data.details"></p></li></ul></aside><article><span class="date">Monday, January 30th 2017</span><section class="post"><h1>Don't Mock Your Code - The Behavior is the Unit</h1><div class="content"><p>I first started really utilizing unit testing and test-driven development while on the <a href="http://web.archive.org/web/20120205035354/https://datamarket.azure.com/">DataMarket</a> team at Microsoft was slowing migrating an ASP.NET WebForms app to MVC. In a team that had no tests maintained by developers (<em>shudder</em> how did we develop software this long?) it was a big cultural change led by my great colleages <a href="https://github.com/jonsequitur">Jon Sequiera</a> and <a href="https://www.linkedin.com/in/dfrenkel">Dmitry Frenkel</a>, who I am very greatful to have the experience of working with.</p>
<p>At the time we&#39;d write tests for our controllers. We&#39;d mock out all the dependencies it would need in a test and provide them. We were also using the <a href="">repository pattern</a> and testing the controller we&#39;d mock that out. The repository pattern was really needed as we couldn&#39;t actually make a call to the database due to a lot of different reasons that basically stem from a monolithic ball of sphagetti code and abomination that was <a href="http://www.ben-morris.com/entity-framework-anti-patterns-how-not-to-use-an-orm-with-sql-server/">Entity Framework 1.0</a>.</p>
<p>That was nice to get developers used to writing tests for their code, but there was a lot of problems with that. Views were not tested at all, due to Razor being untestable at the time (some 32bit vs 64bit issue on the build server or something, see previous comment on monolithic ball of sphagetti). We had bugs in our view not being rendered. Razor was also very logic heavy, and a few abominations were created. Writing new tests required about 3x the mocking code than code that actually did the assertions. Model binding had no tests - you&#39;d know about it 3 days later (maybe) when a tester ran their test suite, or worse, your manager was trying something on the development environment. Forgot a dependency injection registration that you mocked out? App won&#39;t boot at all despite your tests passing. Moreover, when I want to refactor code to move more logic into the controller from the repository that had to much (that had no tests on it), I have to refactor a whole quite of tests. How can we rely on these tests when it still has these huge gaps and maintence problems?</p>
<p>A new approach and that can be referred to behavior-driven development or black box testing is testing the functionality or contracts of the service or app. Essentially all the code that is in that git repo, test that it&#39;s contracts with things outside of it (users, other services it depends on or the API service it has), test those behaviors without mocking any code inside that repository, only other services / interfaces that it depends on (An AWS service, browser ajax calls, etc.) If possible avoid those too - for example, don&#39;t mock your database or Redis - run the server locally, bootstrap it, run the real migrations or whatever, and run your tests.</p>
<p><a href="https://github.com/visionmedia/supertest">supertest</a> and <a href="http://www.davidwhitney.co.uk/Blog/2015/01/07/testing-an-asp-net-webapi-app-in-memory/">ASP.NET WebApi</a> are great in doing this sort of testing for an API server. Start your app, build a request, and assert the response. Make a few calls in a test or nest tests for testing a complicated scenario.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../app'</span>),
      supertest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co-supertest'</span>)(app.listen() <span class="hljs-comment">/* koa app */</span>)

describe(<span class="hljs-string">'Logging in'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  it(<span class="hljs-string">'should return 401 given invalid credentials'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> supertest(app)
      .post(<span class="hljs-string">'/users'</span>)
      .send({
        <span class="hljs-attr">email</span>: <span class="hljs-string">'bob@gmail.com'</span>,
        <span class="hljs-attr">password</span>: <span class="hljs-string">'1234'</span>
      })
      .set(<span class="hljs-string">'Accept'</span>, <span class="hljs-string">'application/json'</span>)
      .expect(<span class="hljs-number">401</span>)
      .expect({
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Invalid Credentials'</span>
      })
      .end()
  })
})
</code></pre>
<p>How simple is that? Of course before this, test data is seeded into the database, and depedant services that are not mocked are started and seeded, like a local redis instance, or a test SQS topic.</p>
<p>What about client code? Opening and closing a browser for every test is not practical. For the rewrite of the portal at Appuri, I had our test bootstrap the entire application and mount it in a <code>div</code> that is not mounted in the DOM by default. Not mounting it in the DOM makes it faster, and also will fail any code that does a global selector (<code>document.body.querySelector[All]</code>), which is very nice. After the test is done, the div is thrown away. Every test instance gets a new appilcation instance and new DOM root for isolation. It&#39;s more heavy weight than unit tests of course, but much less than a Selenium or even a <a href="https://github.com/nathanboktae/mocha-casperjs">mocha-casperjs</a> test.</p>
<p>After using this approach for a year, and getting two other developers up to speed on it, I&#39;m very happy with the results. Functional regressions are extremely rare, and usually due to a missing test or test bug, which is fixed along with the bug fix!</p>
</div><ul class="tags"><li><a href="/tag/front-end">front-end</a></li><li><a href="/tag/testing">testing</a></li><li><a href="/tag/bdd">bdd</a></li></ul></section></article><script src="/site.021b7ad.js"></script></body></html>